<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Extraction Example</title>
    <style>
        canvas {
            border: 1px solid black;
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>Extracted Frames</h1>
    <div id="frames-container"></div>

    <!-- Load the libav.js script -->
    <script type="text/javascript" src="assets/libav/libav-5.4.6.1.1-webm-vp9.js"></script>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', async function() {
            const libav = await LibAV.LibAV();

            async function extractFrames(videoPath, frameCount) {
                const videoData = await fetch(videoPath).then(response => response.arrayBuffer());
                await libav.writeFile("test1.webm", new Uint8Array(videoData));

                const [fmt_ctx, streams] = await libav.ff_init_demuxer_file("test1.webm");
                const stream = streams[0];

                const [, codecContext, packet, frame] = await libav.ff_init_decoder(stream.codec_id, stream.codecpar);

                const frames = [];
                while (frames.length < frameCount) {
                    const res = await libav.av_read_frame(fmt_ctx, packet);
                    if (res === libav.AVERROR_EOF) break;
                    if (res < 0) throw new Error("Error reading frame");

                    if (packet.stream_index === stream.index) {
                        const sendRes = await libav.avcodec_send_packet(codecContext, packet);
                        if (sendRes < 0) throw new Error("Error sending packet to decoder");

                        while (true) {
                            const receiveRes = await libav.avcodec_receive_frame(codecContext, frame);
                            if (receiveRes === libav.AVERROR_EOF || receiveRes === libav.AVERROR(EAGAIN)) break;
                            if (receiveRes < 0) throw new Error("Error receiving frame from decoder");

                            if (receiveRes === 0) {
                                const copiedFrame = await libav.ff_copyout_frame(frame);
                                frames.push(copiedFrame);
                                if (frames.length >= frameCount) break;
                            }
                        }
                    }
                    await libav.av_packet_unref(packet);
                }

                await libav.avformat_close_input_js(fmt_ctx);
                await libav.ff_free_decoder(codecContext, packet, frame);

                return frames;
            }

            async function displayFrames(frames) {
                const container = document.getElementById('frames-container');

                frames.forEach(frame => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = frame.width;
                    canvas.height = frame.height;

                    const yPlane = frame.data.subarray(frame.layout[0].offset, frame.layout[0].offset + frame.layout[0].stride * frame.height);
                    const imgData = ctx.createImageData(frame.width, frame.height);
                    for (let y = 0; y < frame.height; y++) {
                        for (let x = 0; x < frame.width; x++) {
                            const yIndex = y * frame.layout[0].stride + x;
                            const imgIndex = y * frame.width + x;
                            const value = yPlane[yIndex];
                            imgData.data[imgIndex * 4] = value;       // R
                            imgData.data[imgIndex * 4 + 1] = value;   // G
                            imgData.data[imgIndex * 4 + 2] = value;   // B
                            imgData.data[imgIndex * 4 + 3] = 255;     // A
                        }
                    }
                    ctx.putImageData(imgData, 0, 0);
                    container.appendChild(canvas);
                });
            }

            try {
                const frames = await extractFrames('assets/video/test1.webm', 10);
                displayFrames(frames);
            } catch (error) {
                console.error("Failed to load or process the video:", error);
            }
        });
    </script>
</body>
</html>
